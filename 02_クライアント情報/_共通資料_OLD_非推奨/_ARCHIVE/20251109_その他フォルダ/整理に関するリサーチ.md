# JavaScriptプロジェクトのファイル整理とコード品質改善ガイド

JavaScriptプロジェクトにおけるコード整理と品質改善は、プロジェクトの成長に伴い避けて通れない課題です。本レポートでは、重複した検索機能の統合、大規模ファイルの分割、理想的なディレクトリ構造、そして自動化されたチェックシステムの実装について、実践的な解決策を提供します。

## 重複した検索機能の統合戦略

検索機能が4つのファイル（search-engine.js、enhanced-search.js、search-interface.js、reference-system.js）に分散している問題に対して、**Facadeパターン**を用いた統合が最も効果的です。このアプローチにより、既存の機能を維持しながら段階的な移行が可能になります。

**統合実装例**：
```javascript
// search-unified.js
class SearchFacade {
  constructor() {
    this.engines = {
      basic: new BasicSearchEngine(),
      enhanced: new EnhancedSearchEngine(),
      reference: new ReferenceSearchEngine()
    };
  }

  search(query, options = {}) {
    const { type = 'basic', filters, scope } = options;
    
    switch (type) {
      case 'enhanced':
        return this.engines.enhanced.search(query, filters);
      case 'reference':
        return this.engines.reference.search(query, scope);
      default:
        return this.engines.basic.search(query);
    }
  }
}
```

統合プロセスは3つのフェーズで実施します。まず、ESLintの複雑度ルールとdependency-cruiserを使用して重複コードを分析します。次に、共通APIを定義してFacadeクラスを実装し、レガシーメソッドシグネチャ用のアダプターを追加します。最後に、既存のインポートを統一モジュールに段階的に置き換え、廃止予定の警告を表示しながら移行を進めます。

## 大規模ファイルの分割ベストプラクティス

500行を超えるファイルは、**責任別**、**機能別**、または**データフロー別**に分割することで、保守性を大幅に向上させることができます。

**責任別分割の実例**（800行以上のuser-management.jsの場合）：
```javascript
// user-validation.js - 検証ロジック
export const validateUser = (userData) => { /* 検証ロジック */ };

// user-api.js - API通信
export const fetchUser = async (id) => { /* API呼び出し */ };

// user-transforms.js - データ変換
export const normalizeUserData = (rawData) => { /* 正規化処理 */ };

// user-controller.js - メインオーケストレーター
import { validateUser } from './user-validation.js';
import { fetchUser } from './user-api.js';
import { normalizeUserData } from './user-transforms.js';

export class UserController {
  async createUser(userData) {
    const isValid = validateUser(userData);
    if (!isValid) throw new Error('Invalid user data');
    
    const normalizedData = normalizeUserData(userData);
    return await this.userApi.createUser(normalizedData);
  }
}
```

分割の判断基準として、**循環的複雑度を5-6以下**、**ファイルサイズを200-300行以内**、**関数長を20-30行以内**に保つことを推奨します。PlatoやSonarQubeなどの静的解析ツールを使用して、客観的な指標に基づいた分割を行うことが重要です。

## 理想的なディレクトリ構造

現代のJavaScriptプロジェクトでは、従来のレイヤーベース構造から**フィーチャーベース構造**への移行が主流となっています。これにより、関連するコードの局所性が高まり、チーム開発の効率が向上します。

**推奨される構造**：
```
src/
├── features/              # ビジネスドメイン別の機能
│   ├── authentication/
│   │   ├── components/
│   │   ├── services/
│   │   ├── hooks/
│   │   └── utils/
│   ├── search/           # 統合された検索機能
│   │   ├── index.js
│   │   ├── search-facade.js
│   │   ├── strategies/
│   │   └── utils/
│   └── dashboard/
├── shared/               # 共有リソース
│   ├── components/
│   ├── utils/
│   └── services/
├── core/                 # アプリケーション基盤
│   ├── store/
│   ├── router/
│   └── config/
├── testing/              # テストユーティリティ
├── optimization/         # パフォーマンス最適化
└── visualization/        # データ可視化
```

React、Vue.js、Next.jsなどの主要フレームワークも同様のアプローチを採用しており、**Bulletproof React**アーキテクチャやVue 3のComposition API構造が参考になります。特に、Next.js 13以降のApp Routerは、ルートグループを使用した高度な構造化を可能にしています。

## 自動化されたチェックシステムの実装

### 重複コード検出

**jscpd**が最も包括的なツールで、150以上の言語をサポートし、Rabin-Karpアルゴリズムを使用して効率的に重複を検出します。

```json
// .jscpd.json
{
  "threshold": 0.1,
  "reporters": ["html", "console", "badge"],
  "ignore": ["**/__snapshots__/**", "**/*.min.js"],
  "minTokens": 50,
  "minLines": 5,
  "maxSize": "100kb"
}
```

### 循環依存チェック

**Madge**を使用して、視覚的な依存関係グラフを生成し、循環依存を検出します。TypeScriptプロジェクトでは、型インポートをスキップする設定が重要です。

```bash
# 循環依存をチェック
madge --circular --ts-config ./tsconfig.json --extensions ts,tsx src/

# ビジュアルグラフを生成
madge --image graph.svg --circular src/
```

### ファイルサイズ監視

Huskyとlint-stagedを組み合わせたpre-commitフックで、ファイルサイズを自動的にチェックします。

```javascript
// scripts/check-file-size.js
const MAX_FILE_SIZE = 100 * 1024; // 100KB
files.forEach(file => {
  const stats = fs.statSync(file);
  if (stats.size > MAX_FILE_SIZE) {
    console.error(`File ${file} is too large: ${stats.size} bytes`);
    process.exit(1);
  }
});
```

### 未使用コード検出

2024年現在、**Knip**が最も先進的なツールです。90以上のフレームワークプラグインをサポートし、未使用のファイル、エクスポート、依存関係を包括的に検出します。

```javascript
// knip.config.js
export default {
  entry: ['src/index.js', 'scripts/*.js'],
  ignore: ['**/*.d.ts', 'dist/**'],
  rules: {
    files: 'error',
    dependencies: 'error',
    exports: 'error'
  }
};
```

### CI/CD統合

すべてのチェックをGitHub Actionsで自動化し、プルリクエスト時に実行します：

```yaml
name: Code Quality Checks
on:
  pull_request:
    branches: [main]

jobs:
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npx knip --reporter json
      - run: npx madge --circular src/
      - run: npx jscpd src/ --threshold 0.1 --exitCode 1
```

## 実装ロードマップ

移行は段階的に実施することが成功の鍵です。**第1-2週**で現状分析とツールセットアップを行い、**第3-4週**で検索機能の統合と主要ファイルの分割を実施します。**第5-6週**でディレクトリ構造の再編成を行い、**第7-8週**で自動化ツールの完全統合とチームトレーニングを実施します。

重要なのは、各段階で既存機能の動作を保証しながら進めることです。包括的なテストカバレッジを維持し、フィーチャーフラグを使用して新旧実装を切り替え可能にすることで、リスクを最小化できます。

これらの改善により、コードの重複が削減され、ファイルの検索性が向上し、新規開発者のオンボーディング時間が短縮されます。また、自動化されたチェックシステムにより、コード品質が継続的に維持され、技術的負債の蓄積を防ぐことができます。